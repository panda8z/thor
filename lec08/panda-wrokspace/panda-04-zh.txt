如果您的意思是强一致性，
那么通常是男人，
通常也是如此，
例如，
哦，
系统的行为方式与只有一个数据副本的系统会表现得很好，
这非常接近我们对这个定义的理解是什么，
但是是的，
您知道合理的假设是，
强强一致性与可序列化相同，
所以这不是线性化的，
您知道的教训是，
杂草只允许返回陈旧数据只有最新数据，
或者您只能返回最近完成的结果，
好吧，
我有一个最后的最终小例子，
因此我们有两个客户，
其中一个提交对X的写入，
值为3，
然后对两个行为进行4的写入，
我们有另一个客户，
您此时知道客户发出X的读数，
但这是一个问题，
您问客户没有得到正确的答复，
您知道谁知道在实际实施中喜欢它是领导者在某个时候崩溃了，
也许是他的客户端发送了读取的请求，
所以领导者可能由于请求被丢弃而没有得到请求，
或者领导者得到了请求并执行了该请求，
但是响应网络却放弃了响应，
或者可能是领导者得到了它并开始进行处理，
然后在完成处理之前崩溃了，
或者也许做了处理并崩溃了，
然后才说出知道客户的观点的响应，
例如发送了一个请求，
却从未得到响应，
因此在室内机械中我们正在谈论的大多数系统的客户端中，
客户端将重新发送请求，
也许是做一个不同的领导者，
也许是知道什么的那个领导者，
所以它在这里发送了第一个问题请求，
也许在此发送了第二个请求时间点超时，
您知道此时没有响应发送第二个请求，
然后最终得到响应，
事实证明，
您将在实验3中实现此问题，
这是一种合理的服务器交易方式重复请求是为了让他们的服务器通过某种独特的请求号或客户机的某种东西对表进行索引，
服务器记得在其中，
哦，
我已经看到并执行了该请求，
这是我发回的响应，
因为您不想重复执行一个请求，
就可以知道它是否是写请求，
例如您是否不想正确执行请求，
因此服务器必须能够过滤出重复的请求，
并且它们必须能够返回答复以重复最初发送给该请求的答复，
该答复可能已被网络丢弃，
以便服务器记住原始的撬动并响应重发而重复发送，
如果您执行了实验3中的操作，
则如果知道由于服务器领导者在执行从客户端到它的原始读取请求时可能已经看到了值3，
所以可能会将值3返回到此时发送并在此时完成的重复请求，
因此我们必须如果您认为那是合法权利，
您可能会说，
哦，
天哪，
您知道我们在此处发送请求的客户是在X 2 4的权利完成之后，
所以耶稣您此时应该真正返回的是3而不是3，
这是有点像是设计师的问题，
但是如果您认为正在发生的事情是重传是一个低级的关注点，
那您就知道RPC机制的一部分或隐藏在某些库或某些内容中，
并且从客户端应用程序的角度来看，
发生的一切是它此时发送了一个请求并在此时得到了响应，
而这一切都是从客户端的角度来看的，
因此这里的值3完全合法，
因为此请求在很长一段时间内，
它与权利完全并发，
而不是与权利并没有实时排序，
因此，
您知道这三个或四个都是有效的，
就好像真正在此处实时执行的读取请求或在此处实时执行的读取请求如此之大教训是，
如果您正在从应用程序的角度定义线性化能力，
则从应用程序的角度考虑客户端重传-即使使用重传，
这样的请求的实时范围也是从请求的第一次发送开始到应用程序最终获得响应的最后时间，
也许是出于多种原因，
是的，
您可能宁愿获得的是新数据，
而不是陈旧的数据。您知道我是否知道假设请求是什么时候，
什么时候是时间服务器我发送了一个请求，
说哦，
现在几点了，
如果我现在发送请求，
它会向我发送响应，
直到现在2分钟后我才收到响应，
这可能是该应用程序想要宁愿看到我们要得到答复，
也不愿看到一个接近实际得到答复的时间的时间，
而不是过去的时间