好吧，上次我开始谈论线性化能力，而这次我想结束的原因是我们再次谈论线性化能力的原因是这是关于存储一致性系统中强一致性的标准定义，因此例如实验3是服从你的实验室3的需求需要线性化，有时这会出现，因为我们正在谈论一个高度一致的系统，并且我们想知道某个特定行为是否可以接受，而其他时候线性化能力会出现，因为我们我们将要讨论的是一个不可线性化的系统，我们想知道你会以什么方式达到或偏离线性化能力，因此你需要做的一件事是查看特定的操作序列像你的实验3这样执行读写的系统的特定执行，并且能够回答这个问题哦，那是史蒂文斯（Stevens）的运算，我只是看到线性化还是不线性，所以我们将继续练习一下，再加上一些尝试，我将尝试建立一些有趣的事实，这将有助于我们了解所构建系统的后果并了解线性化能力，这是根据特定的操作历史来寻找的，因此始终我们正在谈论的事情是哦，我们观察到你知道客户的一系列请求，然后他们在不同的时间收到了一些响应，他们要求使用不同的信息，以读取不同的数据，并获得各种答案，你知道那是历史我们看到可以线性化，所以这是一个历史示例，该历史可能可以线性化，也可以不线性化，因此让我们假设在某个时间点某些客户组会移到右侧，这个竖线表示客户发送请求的时间我将使用这种表示法来表示该请求是写操作，并要求将变量或键或任何x2值设置为0，以便将某种键和一个值对应于键X的放置数和零在实验3中，这就是我们正在观察客户端发送的内容客户端将该请求发送到我们的服务的情况，并且在某个时候服务已响应并说是的，你说对了，因此我们假设实际上会告诉你何时完成写操作的性质，否则定义不是很有用，所以我们有人提出了这个请求，然后我想在这个示例中还有另一个请求，因为我在这里放了这个标记，这意味着第二个请求在第一个请求完成后开始，你知道其重要性的原因是因为该规则要求线性化历史记录必须与实时匹配，这实际上意味着实时已知的请求已在其他请求之后启动完成第二个请求后，必须按照我们计算出的顺序在第一个请求之后发生，这证明了历史是线性化的线性化可用，所以在此示例中，我在想还有另一个要求要求将X写入值为1的estest，然后稍后可能会启动并发请求以将X设置为2，我说现在我们有两个也许两个不​​同的客户端大约同时发出了将X设置为2的请求不同的值，所以我们当然想知道哪一个将是真实值，然后我们还会读取一些信息，如果你所拥有的全部写得很好，你拥有我们的权利，那么就很难说太多关于线性化线性化能力的信息，因为你不知道你没有任何证据证明系统实际上做了任何事情或显示了任何值，因此我们确实需要读取，因此，我们可以假设我们已读取了一些内容，除非你在客户说过要读取的历史记录中看到我们的内容在这第二次，它获得了对红色按键重音的答案，因此大概知道了这个值，然后可能是同一客户或其他客户提出了另一个请求，但已知该请求完成后及时启动了X的这个读得到了va可能需要等一会儿，所以摆在我们面前的问题是，这个历史是线性的，我们可以采取两种策略来制定一个序列，因为如果我们能得出这五个符合实时和在这种情况下，如果我们能够提出该命令，则每个读取都可以看到该牧师最近执行的命令所写的值，那么这就是历史可线性化的证明。另一种策略是观察这些规则，每个规则都可能意味着一定要先确定在图的边缘，如果我们能够在该操作中找到一个周期，必须在该操作之前发生，我们才能在该图上找到心理，这证明历史不能线性化，对于小的历史，我们实际上可以枚举每个显示此历史记录的单个订单和使用无论如何都无法线性化，这是线性化还是非线性化的任何想法
好吧，所以观察到的是，我们看到使用IU进行读取有点麻烦-然后使用了value读取的值，也许这与你知道存在两个权利，并且一对一的值矛盾-所以我们当然可以我们必须读值三，这显然是我非常错误的事情，但是我们得到了二分之一的权利和一二的阅读权，所以问题是这种阅读顺序是否可能与这两个权利在历史中的显示方式还可以，所以我就是我正在玩的游戏，因为我们有大约两个客户或三个客户，他们在谈论一些你可能知道的服务去年，我们看到的是正确的请求和响应，所以这意味着我们看到一个客户端向X写入请求的请求（你知道对X的请求）和一个，我们在这里看到了响应，所以我们知道的是在这段时间间隔内某处可能是服务实际上是在内部更改x-1的值，这意味着在此时间间隔内某处服务可能在此时间某处更改了其x-2的内部思想，但是你知道它只是在此时间某处并不是说它发生在这里或在这里回答了你的问题是是好的，因此观察是线性化的，并且伴随着线性化能力的实际证明，即证明其线性化的阶次和阶次的演示是的，它是可线性化的，订单是X的第一个右数，值为0，并且服务器大致在同一时间获得了这两个权利，因此仍然必须自己选择顺序，所以我们可以说它可以执行x2的右数首先读取值2，然后执行X的读取，然后执行X的读取，这将是X的首次读取，这时将产生2，然后我们要说下一个操作已执行，这是X的权利为1，然后日因为历史记录中的最后一个操作是将X读为1，所以这证明了历史记录是可线性化的，因为这是操作的总顺序，也是实时匹配的顺序，因此这很好只需经过它，X到0的权利就排在最前面，那是完全直观的，因为它实际上是在其他操作开始X到1的权利之前就已经完成了，对不起X到2的比率排在第二，所以我们要说也许我要在此处标记这样的实时时间，我们可以想象这些操作恰好证明了这里的顺序与实时时间匹配，所以我会在这里写一个大X来标记我们想象的时间该操作正常进行，因此这是第二个操作，然后我们想象下一个操作是读取X的2，我们知道没有实时问题，因为读取X的2实际上是与此u并发的u X之2，你知道这不像钻机X的ht确实从X的X的X的X的读取开始确实是并发的，我们将仅想象发生此操作的那一刻是正确的，所以这是你知道我们不知道的关心何时发生这个问题，我们只说有第二个三分之一，这是第一个操作，现在我们有一个X的权利。我们只说它实时发生在这里，而必须在发生在该命令之前的操作之后发生，这样才能说第四次操作，现在我们已经读取了x1，并且几乎可以随时发生，但是我们可以说它发生在这里，所以这是钻石，因此我们得到了订单，这是该订单与实时一致的演示。也就是说，我们可以为每个操作选择一个在其开始和结束时间内的时间，这将导致该总订单与我们的实时订单相匹配，因此最后一个问题是每次读取是否都看到最接近的右方所写的值相同的变量，所以re是两个V，此读取之前带有具有正确值的权限，这样很好，并且此读取之前带有最接近的相同值的权限，也可以，因此，这表明该历史是线性化的，并且你知道你知道的内容取决于你第一次看到历史记录时的想法，但并非总是立即就可以知道，建立这种复杂的过程是很容易的，因为你知道在查看这些历史记录时很容易被欺骗，你认为哦，x1的权利首先开始所以我们只是假设写入的第一个值必须是一个，但是实际上这不是必需的，如果你的意思是如果这两个值都这样移动了就可以了，如果如果这样的话，只授予值to的权利由客户读取重音值后返回，该值将无法线性化，因为无论你知道什么顺序，我们要拿出的任何订单都必须服从实时订购
因此，我们想出的任何顺序都必须在X的权利之前加上X并加上2，并且由于X在2的见解中没有其他权利，这意味着此时的读取只能看到0或1，因为那是在阅读之前可能仅有的其他2种权利，因此移动你知道将这些权利转移很多会使示例无法线性化是的，我是说第一条垂直线是客户端发送请求的那一刻第二条垂直线是客户收到请求的那一刻，是的，是的，这是一种非常以客户为中心的定义，它表示你知道客户应该看到以下行为，并且在我们发送请求后会发生什么，也许副本可能是一个复杂的网络，它知道几乎与我们无关的业务，我们的定义只是关于客户所看到的内容，我们会在瞬间看到一些灰色区域，例如客户是否需要重新发送要求否则我们还必须知道这是我们必须考虑的事情，所以这是线性的，这是另一个示例，我实际上将以几乎相同的方式开始，而我将首先以相同的方式开始再举个例子，我们有一个X为0的权限，我们拥有这两个并发的权限，并且我们有两个相同的读取，它们与前面的示例到目前为止是完全相同的，因此我们知道这必须是最小的，但是我要让我们想象一下，客户1发出了这两个请求，定义并不真正关心客户，但是她自己的理智将客户1假定为红色X，然后看到两个，然后再使用红色X并看到一个，但是到目前为止，我还说另一个客户端，另一个客户端读取X，它看到一个1，然后另一个客户端是X的第二个读取，它看到-因此这是可线性化的，我们要么必须提出一个订单，要么在此之前里面有一个循环的图，所以你知道令人困惑的事情是，如果一个客户看到这里只有两项权利，那么他们就会以任何顺序知道，或者其中一项权利排在第一位，或者另一种利率排在第一位，并且直观地，客户发现一项拥有价值的权利首先是价值权，然后是价值权，这两个意思是，必须这样，即在看到了这一点之后，必须以两个权利的任何法律顺序出现在一个人的权利之前，以便攀登。我们在这里看到的顺序相同，但是客户体验的对称性清楚地表明了相反的权利，对经验丰富的客户来说，对不起，那就是相反的客户首先看到一个人的权利，然后又看到具有价值的权利，这里的规则之一就是只有一个总的操作顺序不允许不同的客户看到不同的历史或不同的进度存储在系统中的值的演变只有所有客户的总顺序是必须经历与一个订单一致的操作，并且如果一位客户清楚地表明该订单是正确的，那么该客户就正确了，因此，我们应该不能让任何其他客户观察到该订单是其他订单的证据这就是我们在这里所拥有的，所以这是对这里出了什么问题的直观解释，顺便说一下，在我们构建和查看的系统中可能出现这种情况的原因是我们正在构建复制系统你知道筏副本或其中具有缓存的系统，但是我们正在构建的系统具有许多数据副本，因此，可能有许多服务器中包含X副本，并且如果没有，它们在不同时间可能具有不同的值获得提交或某些副本可能具有一个值的某些值，但是尽管如此，如果我们的系统是线性的或高度一致的，则它必须表现得好像只有一个数据副本和一个线性序列对数据执行操作的重要性，这就是一个有趣的例子，因为它可能出现在一种错误的系统中，该系统具有数据的两个副本，一个副本按一个顺序执行这些权限，而另一个副本按以下顺序执行权限：其他顺序，然后我们可以看到这一点，并且线性化能力说不，我们看不到我们不允许在正确的系统中看到它，因此图中的循环早于该图表，这是一种排序稍微证明一点的证据e证明这不是线性化的，是两个的权利必须在客户的两个读取之前，所以有一个这样的箭头，因此此权利必须在读取的客户的读取必须放在右边之前X的值为1的情况，否则，如果你可以想象此权利可能会在订单的较早发生，则此读取将无法看到一项权利，但是在这种情况下，对X的读取将看不到它会看到两项的权利，因为我们知道这个家伙看到了两个
因此对X的读取必须先于X的右边，再对1的X进行的读取必须在对值1的X进行任何读取之前进行，因为包括读取了值1但要在此处获得值1的客户为了使该读取在X的右边与我同时也必须按这两个操作之间的顺序进行，因此我们知道X 1的读取必须在X 2的右边之前，并且这是一个循环，所以没有没有Vinnie或订单，但没有线性订单可以遵守所有这些时间和价值规则，也没有，因为图中存在一个循环，是的，这是一个很好的问题，它定义了关于历史的定义而不是关于必然是系统，所以这并不是说系统设计是线性化的，如果关于设计的某些事情实际上只是一个历史而已，那么，如果我们不了解系统如何在内部运行，唯一知道的就是观察它在执行之前然后我们执行看到任何我们不知道正确的东西，我们是说我们假设它是线性化的，然后我们看到越来越多的操作序列（这些Akash与线性化能力都一致，它们都遵循这些规则，所以你知道我们相信这可能是线性的）这不是全部的线性化，如果我们见过一个不是线性的，那么我们意识到它不是线性化的，所以这是对系统设计的定义，而是对我们观察系统所做的事情的定义从某种意义上说，如果你要尝试正确地设计某些东西，可能会有些不满意，除了简单的意义上，如果你在非常简单的系统中只有一台服务器，而一个服务器一个数据副本，那么就没有一个设计方法的诀窍。没有线程，多核或其他任何东西，要构建一个非常简单的设置来违反它的系统有点困难，但是在任何类型的分布式系统中都非常容易违反它，所以从中得到的教训是，只有在w中成为一阶观察到系统已观察到执行写入操作，所有客户端必须看到值与以相同顺序执行写入操作的系统一致，这是一个非常简单的历史记录，另一个示例假设我们写入的值为1的行为，然后肯定会随后及时写入另一个值客户另一个客户启动了值为2的X的权限，并从服务返回响应，说是的，我做了该权限，然后第三个客户读取了X并得到了你一个，因此这是一个非常简单的示例，显然不是可线性化，因为时间规则意味着唯一可能的顺序是X的权利为1，X的权利为2，X的读数为1，因此必须是该顺序，并且该顺序明显违反了该顺序，这是该顺序的唯一一个顺序显然违反了关于价值的第二条规则，即你知道所拥有的一个订单中最新权利所写的最大价值可能不是1而是2，因此这显然不可线性化，而我提出该价值的原因是因为这是一个可线性化的系统，一个高度一致的系统无法提供过时的数据的论据，并且你知道这种情况可能会再次出现的原因是，你知道也许你有很多副本，每个副本你可能都没有看到所有权利或所有已落实的权利或某些东西，因此也许有些副本可能已经看到了此权限，但只有部分副本看到了此权限，因此，如果你要求的副本滞后一点，它仍然会为X保留价值1，但客户应该永远无法在线性化系统中看到这个旧值，如果没有陈旧的数据，也不允许仍然读取是的，如果时间间隔内有重叠，那么你就知道系统可以合法地执行其中的任何一个，时间和我间隔的时间，这就是他们可以系统执行任何顺序的意义，现在你知道其他人是否知道这不是两次读取，系统就会知道总数自由执行以任意顺序执行，但是因为我们看到了两次读操作，所以我们知道你知道唯一的法律顺序是两个，然后是一个，所以如果两个保留区都在笑，然后再按任意顺序执行，那么读操作实际上可以看到你知道Toby从读取中看到了两个单词和一个单词，这些笨蛋会让你知道系统，直到它致力于读取值为止，它仍然可以自由地以两种顺序返回它们，我将它们用作同义词yeah yeah you大多数人都知道，尽管今天的纸面线性化能力可能没有得到很好的定义，人们的定义确实与这种强大的一致性大相径庭，尽管我认为对定义的确切定义尚无定论。
如果你的意思是强一致性，那么通常是男人，通常也是如此，例如，哦，系统的行为方式与只有一个数据副本的系统会表现得很好，这非常接近我们对这个定义的理解是什么，但是是的，你知道合理的假设是，强强一致性与可序列化相同，所以这不是线性化的，你知道的教训是，杂草只允许返回陈旧数据只有最新数据，或者你只能返回最近完成的结果，好吧，我有一个最后的最终小例子，因此我们有两个客户，其中一个提交对X的写入，值为3，然后对两个行为进行4的写入，我们有另一个客户，你此时知道客户发出X的读数，但这是一个问题，你问客户没有得到正确的答复，你知道谁知道在实际实施中喜欢它是领导者在某个时候崩溃了，也许是他的客户端发送了读取的请求，所以领导者可能由于请求被丢弃而没有得到请求，或者领导者得到了请求并执行了该请求，但是响应网络却放弃了响应，或者可能是领导者得到了它并开始进行处理，然后在完成处理之前崩溃了，或者也许做了处理并崩溃了，然后才说出知道客户的观点的响应，例如发送了一个请求，却从未得到响应，因此在室内机械中我们正在谈论的大多数系统的客户端中，客户端将重新发送请求，也许是做一个不同的领导者，也许是知道什么的那个领导者，所以它在这里发送了第一个问题请求，也许在此发送了第二个请求时间点超时，你知道此时没有响应发送第二个请求，然后最终得到响应，事实证明，你将在实验3中实现此问题，这是一种合理的服务器交易方式重复请求是为了让他们的服务器通过某种独特的请求号或客户机的某种东西对表进行索引，服务器记得在其中，哦，我已经看到并执行了该请求，这是我发回的响应，因为你不想重复执行一个请求，就可以知道它是否是写请求，例如你是否不想正确执行请求，因此服务器必须能够过滤出重复的请求，并且它们必须能够返回答复以重复最初发送给该请求的答复，该答复可能已被网络丢弃，以便服务器记住原始的撬动并响应重发而重复发送，如果你执行了实验3中的操作，则如果知道由于服务器领导者在执行从客户端到它的原始读取请求时可能已经看到了值3，所以可能会将值3返回到此时发送并在此时完成的重复请求，因此我们必须如果你认为那是合法权利，你可能会说，哦，天哪，你知道我们在此处发送请求的客户是在X 2 4的权利完成之后，所以耶稣你此时应该真正返回的是3而不是3，这是有点像是设计师的问题，但是如果你认为正在发生的事情是重传是一个低级的关注点，那你就知道RPC机制的一部分或隐藏在某些库或某些内容中，并且从客户端应用程序的角度来看，发生的一切是它此时发送了一个请求并在此时得到了响应，而这一切都是从客户端的角度来看的，因此这里的值3完全合法，因为此请求在很长一段时间内，它与权利完全并发，而不是与权利并没有实时排序，因此，你知道这三个或四个都是有效的，就好像真正在此处实时执行的读取请求或在此处实时执行的读取请求如此之大教训是，如果你正在从应用程序的角度定义线性化能力，则从应用程序的角度考虑客户端重传-即使使用重传，这样的请求的实时范围也是从请求的第一次发送开始到应用程序最终获得响应的最后时间，也许是出于多种原因，是的，你可能宁愿获得的是新数据，而不是陈旧的数据。你知道我是否知道假设请求是什么时候，什么时候是时间服务器我发送了一个请求，说哦，现在几点了，如果我现在发送请求，它会向我发送响应，直到现在2分钟后我才收到响应，这可能是该应用程序想要宁愿看到我们要得到答复，也不愿看到一个接近实际得到答复的时间的时间，而不是过去的时间
当它最初发送请求时，现在的事实是，如果你知道是否正在使用这样的系统，则必须编写可容忍这些规则的应用程序，而你正在使用线性化系统，例如以下规则
因此，你必须编写你的信息，知道正确的应用程序必须能够容忍你知道他们是否发送了请求，并在一段时间后得到响应，只是你知道你不能编写应用程序，就像我得到了天哪一个响应，意味着我得到响应时的值等于3，对于应用程序以为你认为我知道给定应用程序显示的内容不正确，这取决于该应用程序执行该操作的原因之所以这样，是因为这是6 6 8至4中的一个常见问题，你们将实现一种机制，服务器通过该机制检测重复项并重新发送服务器最初发送的先前答案，如果你最初看到了请求，就可以了吗？如果网络没有掉线，你将在此时返回你将在此处返回的响应，这是一种方便的推理方式，我的意思是说拥有线性化能力等定义的理由到关于这样的问题，我正在使用这种方案，我们可以说很好，实际上，按照那些规则行是可以的，这就是我想说的任何线性问题的线性化能力，是的，你知道，也许我正在自由在这里，但是正在发生的是，我们实时读取了-且读取了一个，并且真正读取了一个，之后实时读取了两个，因此必须按最终顺序按以下顺序进行：意味着一定有权利-在这里的某处是我们的权利，在这里的某处具有值，该值在读取之后-以读取后的最终顺序-在以该顺序读取一个值之前必须存在一项具有价值的权利，只有一项权利不可用，你知道如果我们可以玩多个游戏，但是只有一项可用，因此该权利必须以最终顺序滑入此处，否则我认为可以得出此权利箭头，这些箭头只是捕捉排序是关于规则顺序的规则的一个接一个的暗示，是的，是的，是的，我的意思是任何小时或X，那么对不起，他在自己的rx1之前看到了哪个rx1，是的，所以通过是不，我们不是，我们真的不能说这两种小麦中的哪一种先出现，所以如果我们要用这个箭头来约束最终顺序，我们就不能完全理解所有的错误，我们不是吗？你不知道这两种杂草吗？可能以任何顺序出现，所以我们不可以说这是先出现的，实际上可能是有一个更简单的循环，然后我画了出来，所以我的意思是这可能是因为肯定是损坏是在这四个项目中同意这两项，这四个项目是主要的证据，表明现在有问题了，是否不确定一个周期，我不确定是否有一个周期只是涉及到可以存在的问题，这值得考虑，因为你知道我是否可以想不出更好的办法，否则我肯定会问你一个关于线性化历史的问题n中期还可以，所以今天的报纸就是今天的动物园管理员，我的意思是我们甚至成为动物园管理员的一部分原因是，这是一个成功的现实世界系统，它是一个开源的服务，你知道实际上很多人已经融入了很多人现实世界中的软件，因此它具有一定的现实性和成功性，但你知道从支持动物饲养者设计实际上可能是合理的设计这一观点的角度来看，它是有吸引力的，但这是我们感兴趣的原因我对它感兴趣是因为它有一些更精确的技术要点，所以我们为什么看这篇论文，所以其中一个就是与你所写的筏和定义的筏相反，它确实是一个库你知道可以将Raft库用作某些较大的复制系统的一部分，但是Raft不像独立服务或可以与之交谈的东西，实际上你必须设计应用程序以在Raft库解释下进行交互举个例子，你可能想知道一个有趣的问题，是否可以定义一些有用的系统类型的独立通用系统，这对构建单独的分布式系统的人们会有所帮助，例如是否提供某种服务，可以消除为什么它很痛苦的很大一部分构建分布式系统并将其打包在一个你可以知道任何人都可以使用的独立服务中，所以这实际上是一个关于通用API的外观的问题，我称它为“我不确定” Zookeeper之类的名称是，但是你有一个通用协调服务，另一个问题是Zookeeper的另一个有趣的方面是，当我们构建复制系统而Zookeepers复制系统时，这是因为
它就像一个容错的通用协调服务，并且像大多数系统一样通过复制来获得容错能力，所以你可能知道三，五个或七个，或者谁知道哪个Zookeeper服务器需要花钱来购买这些服务器，就像一台7台服务器的Zookeeper设置是一台简单的单台服务器的价格的7倍一样，因此很想知道你是否购买了7台服务器来运行复制服务，你是否能正确地将7台服务器的性能提高7倍？我们能否做到这一点，所以问题是你知道我们拥有的服务器数量可以达到n倍，而性能却是n倍，所以我将首先讨论第二个问题，因此从这个角度讨论性能只是将zookeeper视作某种服务，我们并不真正在乎该服务是什么，而是使用像复制系统这样的木筏进行复制Zookeeper实际上在名为Zab的东西上运行，出于我们的目的，我们将对其进行处理因为它与木筏几乎完全相同，我只是担心复制的性能，我并不真的担心动物园管理员具体要做什么，因此总体情况是，你知道我们有很多客户，也许数百名数百个客户，就像在小伙子们中一样，我们有一个领导者，领导者有一个与客户交谈的Zookeeper层，然后在Zookeeper层下是管理复制的xab系统，就像筏子一样，这是很多东西这样做是维护一个包含客户发送的操作顺序的日志，该操作与筏实际上非常相似，可能有很多这样的操作，并且每个操作都有一个日志，但是这是一个待处理的新请求，是一个熟悉的设置，因此克林顿请求，并且你知道的Zab层将请求的副本发送到每个副本，副本将其附加到它们的内存法则中（我很可能会坚持到磁盘上），以便它们崩溃时可以取回并重新启动，因此q可能是因为我们添加了更多服务器，所以你知道我们可以拥有四台服务器或五到七台服务器，或者随着我们添加更多的CPU和更多功能而使系统变得更快，你认为你的实验室会因为拥有更多副本而变得更快，因此假设是每个人都复制一台自己的计算机，以便在增加所有收入之间时，确实确实获得了更多的CPU周期，是的，没有什么比增加更多服务器时更快的了