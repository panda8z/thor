好吧，上次我开始谈论线性化能力，
而这次我想结束
我们再次谈论线性化能力的原因是这是关于存储一致性系统中强一致性的标准定义，
因此例如实验3是服从你的实验室3的需求需要线性化，
有时这会出现，
因为我们正在谈论一个高度一致的系统，
并且我们想知道某个特定行为是否可以接受，
而其他时候线性化能力会出现，
因为我们我们将要讨论的是一个不可线性化的系统，
我们想知道你会以什么方式达到或偏离线性化能力，
因此你需要做的一件事是查看特定的操作序列像你的实验3这样执行读写的系统的特定执行，
并且能够回答这个问题哦，
那是史蒂文斯（Stevens）的运算，
我只是看到线性化还是不线性，
所以我们将继续练习一下，
再加上一些尝试，
我将尝试建立一些有趣的事实，
这将有助于我们了解所构建系统的后果并了解线性化能力，
这是根据特定的操作历史来寻找的，

因此始终我们正在谈论的事情是哦，
我们观察到你知道客户的一系列请求，
然后他们在不同的时间收到了一些响应，
他们要求使用不同的信息，
以读取不同的数据，
并获得各种答案，
你知道那是历史我们看到可以线性化，
所以这是一个历史示例，
该历史可能可以线性化，
也可以不线性化，
因此让我们假设在某个时间点某些客户组会移到右侧，
这个竖线表示客户发送请求的时间我将使用这种表示法来表示该请求是写操作，
并要求将变量或键或任何x2值设置为0，
以便将某种键和一个值对应于键X的放置数和零在实验3中，
这就是我们正在观察客户端发送的内容客户端将该请求发送到我们的服务的情况，
并且在某个时候服务已响应并说是的，
你说对了，
因此我们假设实际上会告诉你何时完成写操作的性质，
否则定义不是很有用，
所以我们有人提出了这个请求，
然后我想在这个示例中还有另一个请求，
因为我在这里放了这个标记，
这意味着第二个请求在第一个请求完成后开始，
你知道其重要性的原因是因为该规则要求线性化历史记录必须与实时匹配，
这实际上意味着实时已知的请求已在其他请求之后启动完成第二个请求后，
必须按照我们计算出的顺序在第一个请求之后发生，
这证明了历史是线性化的线性化可用，
所以在此示例中，

我在想还有另一个要求要求将X写入值为1的estest，
然后稍后可能会启动并发请求以将X设置为2，
我说现在我们有两个也许两个不​​同的客户端大约同时发出了将X设置为2的请求不同的值，
所以我们当然想知道哪一个将是真实值，
然后我们还会读取一些信息，
如果你所拥有的全部写得很好，
你拥有我们的权利，
那么就很难说太多关于线性化线性化能力的信息，
因为你不知道你没有任何证据证明系统实际上做了任何事情或显示了任何值，
因此我们确实需要读取，
因此，
我们可以假设我们已读取了一些内容，
除非你在客户说过要读取的历史记录中看到我们的内容在这第二次，
它获得了对红色按键重音的答案，
因此大概知道了这个值，
然后可能是同一客户或其他客户提出了另一个请求，
但已知该请求完成后及时启动了X的这个读得到了va可能需要等一会儿，
所以摆在我们面前的问题是，
这个历史是线性的，

我们可以采取两种策略来制定一个序列，
因为如果我们能得出这五个符合实时和在这种情况下，
如果我们能够提出该命令，
则每个读取都可以看到该牧师最近执行的命令所写的值，
那么这就是历史可线性化的证明。另一种策略是观察这些规则，
每个规则都可能意味着一定要先确定在图的边缘，
如果我们能够在该操作中找到一个周期，
必须在该操作之前发生，
我们才能在该图上找到心理，
这证明历史不能线性化，
对于小的历史，
我们实际上可以枚举每个显示此历史记录的单个订单和使用无论如何都无法线性化，
这是线性化还是非线性化的任何想法