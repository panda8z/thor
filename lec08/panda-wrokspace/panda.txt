alright last time I started talking about linearize ability and I want to finish up this time the reason why we're talking about it again is that it's our kind of standard definition for what strong consistency means in storage style systems so for example lab 3 is a needs to obey your lab 3 needs to be linearizable and sometimes this will come up because we're talking about a strongly consistent system and we're wondering whether a particular behavior is acceptable and other times linearize ability will become come up because we'll be talking about a system that isn't linearizable and we'll be wondering you know in what ways might it fall short or deviate from linearize ability so one thing you need to be able to do is look at a particular sequence of operations a particular execution of some system that executes reads and writes like your lab 3 and be able to answer the question oh was that was that Stevens of operations I just saw linearizable or not I'm so we're going to continue practicing that a little bit now plus I'll try to actually establish some interesting facts that will be helpful for us about what it means about the consequences for the systems we build and look at linearize ability is to find on particular operation history so always the thing we're talking about is oh we observed you know a sequence of requests by clients and then they got some responses at different times and they asked for different different you know to read different data and got various answers back you know is that history that we saw linearizable ok so here's an example of a history that might or might not be linearized able so let's suppose at some point in time some client groups of times gonna move to the right this vertical bar marks the time at which a client sent a request I'm gonna use this notation to mean that the request is a write and asks to set variable or key or whatever x2 value 0 so sort of a key and a value this would correspond to a put of key X and by zero in lab 3 and then this is sort of we're watching what the client send the client sent this request to our service and at some point the service responded and said yes you're right is completed so we're assuming the services of a nature that actually tells you when the write completes otherwise the definition isn't very useful ok so we have this request by somebody to write and then I'm imagining in this example there's another request that because I'm putting this mark here this means the second request started after the first request finished and and you know reason why that's important is because of this rule that linearizable history must match real time and what that really means is that requests that are known in real time to have started after some other request finished the second request has to occur after the first request in whatever order we work out that's the proof that the history was a linearized linearize available ok so in this example I'm imagining there's another request that asks to write X to have value 1 and then a concurrent request may be started a little bit later as to set X to 2 I said now we have two maybe two different clients issued requests at about the same time to set X to two different values so of course we're wondering which one is going to be the real value and then we also have some reads if all you have is writes well well you have us right so it's it's hard to say too much about linearizable linearize ability because you don't know you don't have any proof that the system actually did anything or revealed any values so we really need reads so let's imagine we have some read unless you'll be seeing our in the history that a client said to read at this time and the second time it got an answer for red key accent got value to so presumably actually saw this value and then there was another request by maybe the same client or a different client but known to have started in time after this request finished and this read of X got value while and so the question in front of us is is this history linearizable and there's sort of two strategies we can take we can either cook up a sequence because if we can come up with a total order of these five operations that obeys real time and in which each read sees the value written by the priest most recently proceeding right in the order if we can come up with that order then that's a proof the history is linearizable another strategy is to observe that these rules each one may imply certain this comes before that edges in a graph and if we can find a cycle in this operation must come before that operation we can find a psych on that graph and that's proof that the history isn't linearizable and for small histories we may actually be able to enumerate every single order and use that show this history isn't linearizable anyway any any any thoughts about whether this might be or might not be linearizable yes yes 
okay so the observation is that um it's a little bit troubling that we saw read with IU - and then the read with value want and maybe that contradicts you know there were two rights one with value one on one value - so that so we certainly if we had to read with value three that would obviously be something I got terribly wrong you know but we got there were a right of one in two and a read of one and two so the question is whether this order of reads could possibly be reconciled with the way these two rights show up in the history okay so what I'm what I'm the game we're playing is that we have a like maybe two clients or three clients and they're talking some service you know maybe a raft last year something and what we are seeing is requests and responses right so what this means is that we saw requests from a client to write X to the you know put requests for X and one and we saw the response here so what we know is that somewhere during this interval of time presumably the service actually internally change the value of x - 1 and what this means is that somewhere in this interval of time the service presumably changed its internal idea of the value of x - 2 somewhere in this time but you know it's just somewhere in this time it doesn't mean it happened here or here does that answer your question yes yes okay so the observation is that is linearizable and it's been accompanied by an actual proof of the linearize ability namely a demonstration of the order that shows that it is linearizable and the order is yes it's linearizable and the order is first right of X with value 0 and the server got both of these rights at roughly the same time it's still had to choose the order itself all right so let's just say it could have executed the right of x2 value 2 first and then the read of X then executed the read of X which would the first read of X which at that point would yield 2 and then we're gonna say the next operation had executed it was the right of X to 1 and then the last operation in the history is the read of X to 1 and so this is proof that the history is linearizable because here's an order it's a total order of the operations and this is the order it matches real time so what that means is well just go through it the the right of X to 0 comes first and that's that's totally intuitive since it's actually finished before any other operations started the right of X to 1 comes sorry the rate of X to 2 comes second so we're gonna say maybe that I'm gonna mark here that sort of real time at which we imagine these operations happen to demonstrate that the order here does match real time so it'll say I'll just write a big X here to mark the time when we imagine this operation happened all right so that's the second operation then we're imagining that the next operation is the read of X of 2 we you know there's no real time problem because the read of X of 2 actually was this u concurrently with the right of X of 2 you know it's not like the right of X the read of X of of X right of X with to start there really are concurrent we'll just imagine that that sort of point in time at which this operation happened is right there so this is the you know we don't care when this one happened let's just say there's the first operation second third now we have a right of X of one let's just say it happens here in real time just has to happen after the operations that occur before it in the order so that will say there's the fourth operation and now we have the read of x1 and it can pretty much happen at any time but let's say it happens here okay so this is the Diamonds so we have the order this is the demonstration that the order is consistent with real time that is we can pick a time for each of the operations that's within its start and end time that would cause this total order to match our real time order and so the final question is did each read see the value written by the most closely preceding right of the same variable so there's two V's this read preceded by a right with that correct value so that's good and this read is preceded by a right most closely preceded by a right of the same value also okay so this this is a demonstration that this history was linearizable and you know the you know depends on what you thought when you first saw the history but it's not always immediately clear that set up this complicated is you know it's easy to be tricked when looking at these histories which do you think oh the right of x1 started first so we just sort of assumed that the first value written must be one but that's actually not required here any questions about this if the you mean if these two were moved like this the okay so if if if this if the right with value to was only issued by the client after the read of accent value to returned that wouldn't be linearizable because in whatever order you know any order we come up with has to obey the real-time ordering
so the read of X with two must come before the right of X with one the right of X of one must come before any read of X with value 1 because including client who's read of X with value 1 but in order to get value 1 here and for this read to see to the right of X with I too must come between in in the order between these two operations so we know that the read of X 1 must come before the right of X 2 and that's a cycle alright so there's no there's no Vinnie or order or that but there's no linear order that can obey all of these time and value rules and there isn't because there's a cycle in the in the graph yes that's a good question this this definitions the definition about history's not about necessarily systems so what it's not saying is that a system design is linearizable if something about the design it's really only history by history so if we don't get to know how the system operates internally and the only thing we know is we get to watch it while it executes then before we've seen anything we just don't know right we mean we'll assume it's linearizable and then we see more and more sequences of operations this Akash they're all consistent with linearize ability they all follow these rules so you know we believe it's probably this isn't linearize of all and if we ever seen one that isn't then we realize it's not linearizable so this is yeah it's not a definition on the system design it's a definition on what the what we observe the system to do so in that sense it's maybe a little bit unsatisfying if you're trying to design something right there's not a recipe for how you design you know except in a trivial sense that if you had a single server in very simple systems one server one copy of the data not threaded or multi-core or anything it's a little bit hard to build a system that violates this in a very simple set up but super easy to violate it in any kind of distributed system okay so the lesson from this is that there's only can only be one order in which the system is observed to execute the writes all clients have to see value is consistent with the system executing the writes in the same order here's a very simple history another example supposing we write acts with value 1 and then definitely subsequently in time maybe with another client another client launches a right of X with value 2 and sees a response back from the service saying yes I did the right and then a third client does a read of X and gets got you one so this is a very easy example it's clearly not linearizable because the time rule means that the only possible order is the right of X with 1 the right of X is 2 the read of X with 1 so that has to be the order and that order clearly violates this is the only one order that order clearly violates the second rule about values that is you know the most value written by the most recent right in the owned one order that's possible is not 1 it's 2 so this is clearly not linearizable and the reason I'm bringing it up is because this is the argument that a linearizable system a strongly consistent system cannot serve up stale data right and you know the reason why this might come up is again you know maybe you have lots of replicas each you know maybe haven't seen all the rights or all the committed rights or something so maybe there's some maybe all the replicas have seen this right but only some replicas have seen this right and so if you ask a replica that's lagging behind a little bit it's still gonna have value 1 for X but nevertheless clients should never be able to see this old value in a linearizable system are there no stale data allowed no still reads yeah if there's overlap in the interval then there's then you know that you could the system could legally execute either of them in a real-time and I in the interval so that's the sense in which they could system gonna execute them in either order now you know other you know if it weren't for these two reads the system would have you know total freedom execute that writes in either order but because we saw the two reads we know that you know the only legal order is two and then one yeah so if the two reserva laughing then and then any order then the reads could have seen either in fact you know Toby saw the two and the one words all from the reads these doobies could have you know the system until it committed to the values for the read it still had freedom to return them in either order I'm using them as synonyms yeah yeah you know for most people although possibly not today's paper linearize ability is is well defined and and people's definitions really deviate very much from this strong consistency though is less I think there's less sort of consensus about exactly what the definition might be 
if you meant strong consistency it's often men it's usually men too in ways that are quite close to this like for example that oh the system behaves the same way that a system with only one copy of the data would behave all right which is quite close to what we're getting at with this definition but yeah for you know it's reasonable to assume that strong strong consistency is the same as serializable okay so this is not linearizable and the you know the the lesson is weeds are not allowed to return stale data only only fresh data or you can only return the results of the most recently completed right okay I have a final final little example so we have two clients one of them submits a write to X with value three and then write two acts with value 4 and we have another client and you know at this point in time the client issues a read of X but and this is a question you asked the the client doesn't get a response right you know who knows like it in the sort of actual implementation may be the leader crashed at some point maybe the his client to sent in the read request so the leader maybe didn't get it because the request was dropped or maybe the leader got the request and executed it but the response the network dropped the response or maybe the leader got it and started to process up and then crash before finished processing and or maybe did process it and crash before saying the response who knows when the clients point of view like sent a request and never got a response so in the interior machinery of the client for most of the systems we're talking about the client is going to resend the request maybe do a different leader maybe the same leader who knows what so it sent the first question quest here and maybe it sends the second request at this point in time it times out you know no response sends the second request at this point and then finally gets a response it turns out that and you're going to implement this in lab 3 that a reasonable way of servers dealing with repeated requests is for their servers to keep tables sort of indexed by some kind of unique request number or something from the clients in which the servers remember oh I already saw that request and executed it and this was the response that I sent back because you don't want to execute a request twice you know if it's a for example if it's a write request you don't want to execute requests right so the server's have to be able to filter out duplicate requests and they have to be able to return the reply to repeat the reply that the originally sent to that request which perhaps has dropped by the network so that servers remember the original pry and repeat it in response to the resend and if you do that which you will in lab 3 then if you know since the server the leader could have seen value 3 when it executed the original read request from client to it could return value 3 to the repeated requests that was sent at this time and completed at this time and so we have to make a call on whether that is legal right you could argue that oh gosh you know the client we sent the request here this was after the right of X 2 4 completed so Jesus what you really should return for at this point instead of 3 and this is like a little bit a question of it's like a little bit up the designer but if what you view is going on is that the retransmissions are a low-level concern that's you know part of the RPC machinery or hidden in some library or something and that from the client applications point of view all that happened was that it's sent a request at this time and got a response at this time and that's all that happened from the clients point of view then a value of 3 is totally legal here because this request took a long time it's completely concurrent with the right not ordered in real time with the right and therefore either the three or the four is valid you know as if the read requests that really executed here in real time or or here in real time so the larger lesson is if you have client retransmissions the from the application point of view if you're defining linearize ability from the applications point of view - even with retransmissions the real time extent of the requests like this is from the very first transmission of the requests to the final time at which the application actually got the response maybe after many reasons yes you might rather you got fresh data than stale data you know if I'm you know supposing the request is what time it what time is it that's a time server I sent a request saying Oh what time is it and it sends me a response you know yeah if I send a request now and I don't get the response until 2 minutes from now dude some Network issue it may be that the application would like prefer to see we're gonna get the response it would prefer to see a time that was close to the time at which had actually got the response rather than a time deep in the past
when it originally sent the request now the fact is that if you you know if you're using a system like this you have to write applications that are tolerant of these rules you're using a linearizable system like these are the rules
and so you must write you know correct applications must be tolerant of you know if they send a request and they get a response a while later they just you know you can't are not allowed to write the application as if oh gosh if I get a response that means that the value at the time I got the response was equal to 3 that is not OK for applications to think you know what that I have that plays out for a given application depends on what the application is doing the reason I bring this up is because it's a common question in 6 6 8 to 4 you guys will implement the machinery by which servers detect duplicates and resend the previous answer that the server originally sent and the question will come up is it ok if you originally saw the request here to return at this point in time the response that you would have sent back here if the network hadn't dropped it and it's it's handy to have a kind of way of reasoning I mean one reason to have definitions like linearize abilities to be able to reason about questions like that right i'm using using this scheme we can say well it actually is okay by those rules all right that's all i want to say about linearize ability of any any lingering questions yeah well you know maybe I'm taking liberties here but what's going on is that in real time we have a read of - and a read of one and the read of one really came after in real time the read of two and so must come must be in this order in the final order that means there must have been a right of - somewhere in here it's our right with value one somewhere in here that is after the read of - in the final order right after the read of - and before the read of one in that order there must be a right with value one there's only one right with a value unavailable you know if there were more than one we maybe could play games but there's only one available so this right must slip in here in the final order or therefore I felt able to draw this arrow and these arrows just capture the sort of one by one implication of the rules on what the order must look like yeah all right yeah I mean any hour or X so which sorry which which yeah his own rx1 he sees it before his own rx1 okay so the via yep well we're not we're not we're not really able to say which of these two wheats came first so we can't quite for all this error if we mean this arrow to constrain the ultimate order we're not you know the these two weeds could come in either order so we're not allowed to say this one came before that one it could be there's a simpler cycle actually then I've drawn so I mean it may be because certainly the that the damage is in these four items I agree with that these two these four items kind of are the main evidence that something is wrong now whether a cycle I'm not sure whether there's a cycle that just involves that there could be okay this is worth thinking about cuz you know if I can't think of anything better or I'll certainly ask you a question about linearizable histories on midterm okay so today's paper today's paper zookeeper and I mean part of the reason we're even zookeeper paper is that it's a successful real world system it's an open source you know service that actually a lot of people ron has been incorporated into a lot of real world software so there's a certain kind of reality and success to it but you know that makes attractive from the point of view of kind of supporting the idea that the zookeepers design might actually be a reasonable design but the reason we're interested in in it I'm interested in it is for to somewhat more precise technical points so why are we looking at this paper so one of them is that in contrast to raft like the raft you've written and raft as that's defined it's really a library you know you can use a raft library as a part of some larger replicated system but raft isn't like a standalone service or something that you can talk to it's you really have to design your application to interact at the raft library explicitly so you might wonder it's an interesting question whether some useful system sort of standalone general-purpose system could be defined that would be helpful for people building separate distributed systems like is there serve some service that can bite off a significant portion of why it's painful to build distributed systems and sort of package it up in a standalone service that you know anybody can use so this is really the question of what would an API look like for a general purpose I'll call it I'm not sure what the right name for things like zookeeper is but you've got a general purpose coordination service and the other question the other interesting aspect of zookeeper is that when we build replicated systems and zookeepers a replicated system because among other things
it's it's like a fault-tolerant general-purpose coordination service and it gets fault tolerance like most systems by replication that is there's a bunch of you know maybe three or five or seven or who knows what zookeeper servers it takes money to buy those servers right like a 7 server zookeeper setup is 7 times expensive as a sort of simple single server so it's very tempting to ask if you buy 7 servers to run your replicated service can you get 7 times the performance out of your 7 servers right and you know how could we possibly do that so the question is you know we have n times as many servers can that yield us n times the performance so I'm gonna talk about the second question first so from the point of view this discussion about performance I'm just going to view zookeeper as just some service we don't really care what the service is but replicated with a raft like replication system zookeeper actually runs on top of this thing called Zab which for our purposes we'll just treat as being almost identical to the raft and I'm just worried about the performance of the replication I'm not really worried about what zookeepers specifically is up to so the general picture is that you know we have a bunch of clients maybe hundreds maybe hundreds of clients and we have just as in the lads we have a leader the leader has a zookeeper layer that clients talk to and then under the zookeeper layer is the xab system that manages replication then just like rafts what was a a lot of what's that is doing is maintaining a log that contains the sequence of operations that clients have sent in really very similar to raft may have a bunch of these and each of them has a log but it's a pending new request that's a familiar set up so the Clinton's in a request and the Zab layer you know sends a copy of that request to each of the replicas and the replicas append this to their in-memory law I'd probably persisted onto a disk so they can get it back if they crash and restart so the question is as we add more servers you know we could have four servers or five or seven or whatever does the system get faster as we add more more CPUs more horsepower to it do you think your labs will get faster as you have more replicas assuming they're each replicas its own computer right so that you really do get more CPU cycles as you add more revenues between all the yeah yeah there's nothing about this that makes it faster as you add more servers
 